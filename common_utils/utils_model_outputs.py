from dataclasses import dataclass, field
from typing import List, Optional
import pandas as pd


# we need to figure out if we are storing logged fatalities or not
# And this is also a good place to decide on the uncertainty quantification. Right now var, but maybe HDI or something else.
# you migth also waht the a non-step specifci list of pgm? So you can rectrate the full df from here? Otherwsie this could turn into a mess

@dataclass
class ModelOutputs:
    """
    A data class for storing and managing model outputs for evaluation as well as true forcasting.
    
    Attributes:
        y_score (Optional[List[float]]): Model predictions (magnitude, e.g. logged fatalites).
        y_score_prob (Optional[List[float]]): Model prediction (probabilities).
        y_var (Optional[List[float]]): Variance of the model predictions.
        y_var_prob (Optional[List[float]]): Variance of the model prediction probabilities.
        y_true (Optional[List[float]]): True values.
        y_true_binary (Optional[List[int]]): True binary values (0 or 1).
        pg_id (Optional[List[int]]): The priogrid id.
        c_id (Optional[List[int]]): The country id.
    """

    y_score: Optional[List[float]] = field(default_factory=list)
    y_score_prob: Optional[List[float]] = field(default_factory=list)
    y_var: Optional[List[float]] = field(default_factory=list)
    y_var_prob: Optional[List[float]] = field(default_factory=list)
    y_true: Optional[List[float]] = field(default_factory=list)
    y_true_binary: Optional[List[int]] = field(default_factory=list)
    pg_id: Optional[List[int]] = field(default_factory=list)
    c_id: Optional[List[int]] = field(default_factory=list)

    @classmethod
    def make_output_dict(cls, steps=36) -> dict:
        """
        Generates a dictionary of ModelOutputs instances for a specified number of forecasting steps.

        This method facilitates the batch creation of output containers for multiple forecasting steps, initializing them with empty lists.

        Args:
            steps (int): The number of forecasting steps for which to generate model outputs. Defaults to 36.

        Returns:
            dict: A dictionary where each key is a step label (e.g., 'step01', 'step02', ...) and each value is an instance of ModelOutputs.

        Example:
            >>> from utils_model_outputs import ModelOutputs
            >>> output_dict = ModelOutputs.make_output_dict(steps=36)
            >>> output_dict['step01'].y_score = [0.1, 0.2, 0.3]
            >>> output_dict['step01'].y_true = [1, 0, 1]
            >>> output_dict['step02'].y_score = [0.2, 0.3, 0.2]
            >>> output_dict['step02'].y_true = [1, 1, 0]
            >>> ...
        """
        return {f"step{str(i).zfill(2)}": cls() for i in range(1, steps + 1)}


# this might not work out of the box, but it is a good start
# It is very slow and not a correct solution right now. 

    @staticmethod
    def output_dict_to_dataframe(output_dict: dict) -> pd.DataFrame:
        """
        Converts a dictionary of ModelOutputs instances into a pandas DataFrame for easy analysis.

        This static method transforms a structured dictionary of model outputs into a DataFrame, where each row corresponds to a forecasting step and columns represent different outputs.

        Args:
            output_dict (dict): A dictionary of ModelOutputs instances, typically generated by the make_output_dict class method.

        Returns:
            pd.DataFrame: A pandas DataFrame where each row indexes a forecasting step and columns correspond to the various outputs stored in ModelOutputs.

        Example:
            >>> output_df = ModelOutputs.output_dict_to_dataframe(output_dict)
        """
        # Transforming lists within the ModelOutputs instances to strings for DataFrame compatibility
        transformed_dict = {key: {attr: ','.join(map(str, getattr(instance, attr))) for attr in instance.__dataclass_fields__} for key, instance in output_dict.items()}
        return pd.DataFrame.from_dict(transformed_dict, orient='index')